<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Minecraft 1.20.1 Forge Mod 开发笔记0：新建文件夹</title>
      <link href="/2024/11/forge-dev-0/"/>
      <url>/2024/11/forge-dev-0/</url>
      
        <content type="html"><![CDATA[<h1 id="项目的创建"><a href="#项目的创建" class="headerlink" title="项目的创建"></a>项目的创建</h1><p>谷歌搜索Forge mdk,然后从Forge官网下载即可。下载的时候必须留意Forge的版本，<br>否则有可能开发出来的Mod和游戏不兼容。还要注意和Optifine是否兼容，版本太新的话是没有对应的Op的。<br>Forge不同版本之间的差异比较明显，至少中间版本号一样才比较保险。这里用的是Forge 47.2.18</p><p>下载完毕后解压，在目录中执行<code>gradlew genIntellijRun</code>可以创建Idea的环境，方便在IDE中运行和调试。</p><p>PS: Idea的构建功能有时候会抽风，导致在代码没有问题的情况下，游戏运行的时候报错。其次，它的构建功能不会输出最终的jar。<br>解决方案是在终端中使用<code>gradlew build</code>和<code>gradlew runClient</code>，不通过Idea</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.mcjty.eu/docs/1.20/ep1">https://www.mcjty.eu/docs/1.20/ep1</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> Minecraft </tag>
            
            <tag> Java - Forge </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32 HAL库GPIO初始化函数分析</title>
      <link href="/2024/07/stm32-hal-gpio-init-comment/"/>
      <url>/2024/07/stm32-hal-gpio-init-comment/</url>
      
        <content type="html"><![CDATA[<h2 id="函数代码及其注释"><a href="#函数代码及其注释" class="headerlink" title="函数代码及其注释"></a>函数代码及其注释</h2><p>HAL库的封装非常完善，在可以使用HAL_GPIO_Init函数初始化端口用于外部中断，无需自己手动修改寄存器什么的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_Init</span><span class="params">(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint32_t</span> position = <span class="number">0x00</span>u; <span class="comment">// 记录当前初始化的是第几个管脚</span></span><br><span class="line">  <span class="type">uint32_t</span> ioposition; </span><br><span class="line">  <span class="type">uint32_t</span> iocurrent; </span><br><span class="line">  <span class="type">uint32_t</span> temp;</span><br><span class="line">  <span class="type">uint32_t</span> config = <span class="number">0x00</span>u;</span><br><span class="line">  __IO <span class="type">uint32_t</span> *configregister; <span class="comment">/* Store the address of CRL or CRH register based on pin number */</span></span><br><span class="line">  <span class="type">uint32_t</span> registeroffset;       <span class="comment">/* offset used during computation of CNF and MODE bits placement inside CRL or CRH register */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Check the parameters */</span></span><br><span class="line">  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));</span><br><span class="line">  assert_param(IS_GPIO_PIN(GPIO_Init-&gt;Pin));</span><br><span class="line">  assert_param(IS_GPIO_MODE(GPIO_Init-&gt;Mode));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Configure the port pins */</span></span><br><span class="line">  <span class="keyword">while</span> (((GPIO_Init-&gt;Pin) &gt;&gt; position) != <span class="number">0x00</span>u)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Get the IO position */</span></span><br><span class="line">    <span class="comment">/* 记录当前初始化的是哪个管脚（二进制形式，1为初始化的管脚）*/</span></span><br><span class="line">    ioposition = (<span class="number">0x01</span>uL &lt;&lt; position);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Get the current IO position */</span></span><br><span class="line">    <span class="comment">/* 中间变量，用于检查position指定的管脚是否被指定要初始化 */</span></span><br><span class="line">    iocurrent = (<span class="type">uint32_t</span>)(GPIO_Init-&gt;Pin) &amp; ioposition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iocurrent == ioposition)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check the Alternate function parameters */</span></span><br><span class="line">      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */</span></span><br><span class="line">      <span class="comment">/* 根据输入变量生成对应寄存器的值 */</span></span><br><span class="line">      <span class="keyword">switch</span> (GPIO_Init-&gt;Mode)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* If we are configuring the pin in OUTPUT push-pull mode */</span></span><br><span class="line">        <span class="comment">/* 推挽输出配置 */</span></span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_OUTPUT_PP:</span><br><span class="line">          <span class="comment">/* Check the GPIO speed parameter */</span></span><br><span class="line">          assert_param(IS_GPIO_SPEED(GPIO_Init-&gt;Speed));</span><br><span class="line">          config = GPIO_Init-&gt;Speed + GPIO_CR_CNF_GP_OUTPUT_PP;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we are configuring the pin in OUTPUT open-drain mode */</span></span><br><span class="line">        <span class="comment">/* 开漏输出配置 */</span></span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_OUTPUT_OD:</span><br><span class="line">          <span class="comment">/* Check the GPIO speed parameter */</span></span><br><span class="line">          assert_param(IS_GPIO_SPEED(GPIO_Init-&gt;Speed));</span><br><span class="line">          config = GPIO_Init-&gt;Speed + GPIO_CR_CNF_GP_OUTPUT_OD;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we are configuring the pin in ALTERNATE FUNCTION push-pull mode */</span></span><br><span class="line">        <span class="comment">/* 特殊功能推挽输出配置 */</span></span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_AF_PP:</span><br><span class="line">          <span class="comment">/* Check the GPIO speed parameter */</span></span><br><span class="line">          assert_param(IS_GPIO_SPEED(GPIO_Init-&gt;Speed));</span><br><span class="line">          config = GPIO_Init-&gt;Speed + GPIO_CR_CNF_AF_OUTPUT_PP;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we are configuring the pin in ALTERNATE FUNCTION open-drain mode */</span></span><br><span class="line">        <span class="comment">/* 特殊功能开漏输出配置 */</span></span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_AF_OD:</span><br><span class="line">          <span class="comment">/* Check the GPIO speed parameter */</span></span><br><span class="line">          assert_param(IS_GPIO_SPEED(GPIO_Init-&gt;Speed));</span><br><span class="line">          config = GPIO_Init-&gt;Speed + GPIO_CR_CNF_AF_OUTPUT_OD;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we are configuring the pin in INPUT (also applicable to EVENT and IT mode) */</span></span><br><span class="line">        <span class="comment">/* 普通输入、中断输入和事件输入 */</span></span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_INPUT:</span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_IT_RISING:</span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_IT_FALLING:</span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_IT_RISING_FALLING:</span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_EVT_RISING:</span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_EVT_FALLING:</span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_EVT_RISING_FALLING:</span><br><span class="line">          <span class="comment">/* Check the GPIO pull parameter */</span></span><br><span class="line">          assert_param(IS_GPIO_PULL(GPIO_Init-&gt;Pull));</span><br><span class="line">          <span class="keyword">if</span> (GPIO_Init-&gt;Pull == GPIO_NOPULL)</span><br><span class="line">          &#123;</span><br><span class="line">            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (GPIO_Init-&gt;Pull == GPIO_PULLUP)</span><br><span class="line">          &#123;</span><br><span class="line">            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Set the corresponding ODR bit */</span></span><br><span class="line">            GPIOx-&gt;BSRR = ioposition;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="comment">/* GPIO_PULLDOWN */</span></span><br><span class="line">          &#123;</span><br><span class="line">            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Reset the corresponding ODR bit */</span></span><br><span class="line">            GPIOx-&gt;BRR = ioposition;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If we are configuring the pin in INPUT analog mode */</span></span><br><span class="line">        <span class="keyword">case</span> GPIO_MODE_ANALOG:</span><br><span class="line">          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Parameters are checked with assert_param */</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Check if the current bit belongs to first half or last half of the pin count number</span></span><br><span class="line"><span class="comment">       in order to address CRH or CRL register*/</span></span><br><span class="line">      configregister = (iocurrent &lt; GPIO_PIN_8) ? &amp;GPIOx-&gt;CRL     : &amp;GPIOx-&gt;CRH;</span><br><span class="line">      registeroffset = (iocurrent &lt; GPIO_PIN_8) ? (position &lt;&lt; <span class="number">2u</span>) : ((position - <span class="number">8u</span>) &lt;&lt; <span class="number">2u</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Apply the new configuration of the pin to the register */</span></span><br><span class="line">      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) &lt;&lt; registeroffset), (config &lt;&lt; registeroffset));</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*--------------------- EXTI Mode Configuration ------------------------*/</span></span><br><span class="line">      <span class="comment">/* 外部中断配置 */</span></span><br><span class="line">      <span class="comment">/* Configure the External Interrupt or event for the current IO */</span></span><br><span class="line">      <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; EXTI_MODE) == EXTI_MODE)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Enable AFIO Clock */</span></span><br><span class="line">        __HAL_RCC_AFIO_CLK_ENABLE();</span><br><span class="line">        <span class="comment">/* EXTICR 16位 总共四个，每个EXITCR分别控制四个中断，总共 4 * 4 = 16个中断</span></span><br><span class="line"><span class="comment">           position &gt;&gt; 2  ==&gt;  position / 4 ，把 0-15 转换为 0-4 即找到对应的寄存器</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        temp = AFIO-&gt;EXTICR[position &gt;&gt; <span class="number">2u</span>]; </span><br><span class="line">        <span class="comment">/* position &amp; 3  ==&gt;  position % 4 ，即找到在当前EXITCR寄存器中，position对应的是哪一个中断。</span></span><br><span class="line"><span class="comment">           乘4是因为左移的单位是 “中断数”，一个中断对应4位，我要左移 n个中断 意味着要左移 n * 4位。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        CLEAR_BIT(temp, (<span class="number">0x0F</span>u) &lt;&lt; (<span class="number">4u</span> * (position &amp; <span class="number">0x03</span>u)));</span><br><span class="line">        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) &lt;&lt; (<span class="number">4u</span> * (position &amp; <span class="number">0x03</span>u)));</span><br><span class="line">        AFIO-&gt;EXTICR[position &gt;&gt; <span class="number">2u</span>] = temp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Enable or disable the rising trigger */</span></span><br><span class="line">        <span class="comment">/* 设置上升沿触发 */</span></span><br><span class="line">        <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; RISING_EDGE) == RISING_EDGE)</span><br><span class="line">        &#123;</span><br><span class="line">          SET_BIT(EXTI-&gt;RTSR, iocurrent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          CLEAR_BIT(EXTI-&gt;RTSR, iocurrent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Enable or disable the falling trigger */</span></span><br><span class="line">        <span class="comment">/* 设置下降沿触发 */</span></span><br><span class="line">        <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; FALLING_EDGE) == FALLING_EDGE)</span><br><span class="line">        &#123;</span><br><span class="line">          SET_BIT(EXTI-&gt;FTSR, iocurrent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          CLEAR_BIT(EXTI-&gt;FTSR, iocurrent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Configure the event mask */</span></span><br><span class="line">        <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; GPIO_MODE_EVT) == GPIO_MODE_EVT)</span><br><span class="line">        &#123;</span><br><span class="line">          SET_BIT(EXTI-&gt;EMR, iocurrent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          CLEAR_BIT(EXTI-&gt;EMR, iocurrent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Configure the interrupt mask */</span></span><br><span class="line">         <span class="comment">/* 设置中断屏蔽 为0时不允许对应中断 */</span></span><br><span class="line">        <span class="keyword">if</span> ((GPIO_Init-&gt;Mode &amp; GPIO_MODE_IT) == GPIO_MODE_IT)</span><br><span class="line">        &#123;</span><br><span class="line">          SET_BIT(EXTI-&gt;IMR, iocurrent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          CLEAR_BIT(EXTI-&gt;IMR, iocurrent);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 配置下一位</span></span><br><span class="line">position++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="附：各寄存器的结构"><a href="#附：各寄存器的结构" class="headerlink" title="附：各寄存器的结构"></a>附：各寄存器的结构</h2><h3 id="EXTICR-外部中断控制寄存器"><a href="#EXTICR-外部中断控制寄存器" class="headerlink" title="EXTICR 外部中断控制寄存器"></a>EXTICR 外部中断控制寄存器</h3><p>总共有四个，结构都类似<br><img src="https://cdn.ncmc.me/notes/2024/07/02/01.jpg" alt="EXTICR"></p><h3 id="EXTI-IMR-外部中断屏蔽寄存器"><a href="#EXTI-IMR-外部中断屏蔽寄存器" class="headerlink" title="EXTI_IMR 外部中断屏蔽寄存器"></a>EXTI_IMR 外部中断屏蔽寄存器</h3><p><img src="https://cdn.ncmc.me/notes/2024/07/02/02.jpg" alt="EXTICR"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> C语言 </tag>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32F103的RCC时钟及其设置</title>
      <link href="/2024/07/stm32-rcc-clock/"/>
      <url>/2024/07/stm32-rcc-clock/</url>
      
        <content type="html"><![CDATA[<h2 id="STM32F103的系统时钟源"><a href="#STM32F103的系统时钟源" class="headerlink" title="STM32F103的系统时钟源"></a>STM32F103的系统时钟源</h2><p>和C51不同STM32F103的系统时钟源有好几个，根据官方手册，截取一个比较重要的部分如下：<br><img src="https://cdn.ncmc.me/notes/2024/07/01/00.jpg" alt="时钟截图"><br>从图中可以看出，系统时钟SYSCLK的来源包括HSI,PLLCLK,HSE，可以通过软件选择它们中的其中一个。</p><h3 id="HSE-高速外部时钟信号"><a href="#HSE-高速外部时钟信号" class="headerlink" title="HSE 高速外部时钟信号"></a>HSE 高速外部时钟信号</h3><p>这个时钟信号直接来源于外部晶振（或者外部时钟），通过 OSC_IN 和 OSC_OUT 两个端子输入。晶振的大小介于4-16MHz。</p><h3 id="HSI-内部RC振荡信号"><a href="#HSI-内部RC振荡信号" class="headerlink" title="HSI 内部RC振荡信号"></a>HSI 内部RC振荡信号</h3><p>由内部 8MHz RC振荡器生成。</p><h3 id="PLL-锁相环"><a href="#PLL-锁相环" class="headerlink" title="PLL 锁相环"></a>PLL 锁相环</h3><p>PLL 允许以 HSE 或者 HSI 作为原始信号，经过处理后得到系统时钟信号。由图可知，HSI 信号频率减半后，输入到 PLLSRC 。HSE则直接输入 PLLSRC 。可以通过软件选择用哪一个作为原始信号。PLLMUL 可以把输入信号的频率乘某个倍数，例如 8MHz 的 HSE 信号，输入到PLLMUL，用软件设置乘4倍后，就能得到 32MHz 的 PLLCLK 信号。</p><h2 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h2><p>主要利用 <code>HAL_RCC_OscConfig</code> 和  <code>HAL_RCC_ClockConfig</code> 函数进行设置。<br>这个函数原本是用STM32CubeMX生成的，在其基础上进行了修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SystemClock_Config</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Initializes the RCC Oscillators according to the specified parameters</span></span><br><span class="line"><span class="comment">  * in the RCC_OscInitTypeDef structure.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 这里同时配置HSE和PLL</span></span><br><span class="line">  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; <span class="comment">// 要设置的信号源</span></span><br><span class="line">  RCC_OscInitStruct.HSEState = RCC_HSE_ON; <span class="comment">// 设置为启用</span></span><br><span class="line">  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; <span class="comment">// 设置启用PLL</span></span><br><span class="line">  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; <span class="comment">// 设置PLL原始信号为HSE</span></span><br><span class="line">  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL4; <span class="comment">// 设置PLLMUL倍率为4</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; <span class="comment">// 设置系统时钟源为PLLCLK</span></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它类型的时钟源也类似。</p><h3 id="测试是否成功设置"><a href="#测试是否成功设置" class="headerlink" title="测试是否成功设置"></a>测试是否成功设置</h3><p>调用 <code>HAL_RCC_GetSysClockFreq</code> 函数，在调试器中查看其返回值即可知道系统的时钟频率是否和预期的一致。</p>]]></content>
      
      
      
        <tags>
            
            <tag> stm32 </tag>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32CubeIDE Windows版配置</title>
      <link href="/2024/07/stm32CubelIDE-First-Time/"/>
      <url>/2024/07/stm32CubelIDE-First-Time/</url>
      
        <content type="html"><![CDATA[<p>网上的教程都说，安装好了STM32CubeIDE直接创建工程就可以了，然而实际测试下来却完全不是这样。</p><h2 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h2><p>安装完毕后，首先要把界面显示语言更改为中文。因为这个ide是基于eclipse的，因此导入eclipse的汉化包就行。</p><p><code>Help -&gt; Install New Software...</code> 打开安装窗口<br><img src="https://cdn.ncmc.me/notes/2024/07/00/01.jpg" alt="安装窗口"></p><p>在下拉选单上选择官方的软件源，选中中文包（Babel Language Pack for eclipse in Chinese），打勾，点击下一步，<br>窗口会显示准备安装的所有包，然后点击完成即可。</p><p>由于软件源在国外，所以可能会出现下载缓慢、失败的情况。只需要在<code>Work With</code>框输入国内镜像源地址，点击<code>Add...</code>即可。<br>如南京大学镜像源地址：<a href="https://mirrors.nju.edu.cn/eclipse/technology/babel/update-site/latest/">https://mirrors.nju.edu.cn/eclipse/technology/babel/update-site/latest/</a></p><h2 id="字符、图标大小调整"><a href="#字符、图标大小调整" class="headerlink" title="字符、图标大小调整"></a>字符、图标大小调整</h2><p>默认情况下，IDE的图标很小，编辑器里面的字符也非常的小。图标小的问题要通过 主程序右键 -&gt; 属性 -&gt; 兼容性<br> -&gt; 更改高DPI设置… -&gt; 勾选替代高DPI缩放行为，并改为系统（增强）</p><p>字符大小和样式的调整在窗口 -&gt; 首选项 -&gt; 常规 -&gt; 外观 -&gt; 颜色和字体 中调整。</p><p>后来还发现C代码中的注释是灰色的，在黑暗模式下几乎看不清，因此改为了绿色。修改选项在<br>首选项 -&gt; C&#x2F;C++ -&gt; 编辑器（Editor） -&gt; 语法高亮颜色（Syntax Coloring）中</p><h2 id="安装固件包"><a href="#安装固件包" class="headerlink" title="安装固件包"></a>安装固件包</h2><p>旧版本似乎是可以在创建项目的时候自动下载相应固件包的，但是创建的时候却显示需要登录。不想登录的话，可以在github上下载固件包自行安装。<br>如STM32F1系列的固件包地址是：<a href="https://github.com/STMicroelectronics/STM32CubeF1">https://github.com/STMicroelectronics/STM32CubeF1</a></p><p>根据对应的tag下载合适的版本，并解压到对应文件夹，一般是 %homepath%&#x2F;Stm32Cube&#x2F;Repository&#x2F;<br>在帮助 -&gt; Manager Embedded Software Packages 里面可以检查安装成功与否</p><p>然后再重新创建项目，就能正常生成初始代码了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式 </tag>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言long类型的位数</title>
      <link href="/2024/06/c-long-bits/"/>
      <url>/2024/06/c-long-bits/</url>
      
        <content type="html"><![CDATA[<h1 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> l = LONG_MAX + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld,%lld\n&quot;</span>,LONG_MAX,l);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><p>在 Windows 上的测试结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2147483647,2147483648</span><br></pre></td></tr></table></figure><p>在 Linux 上的测试结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9223372036854775807,-9223372036854775808</span><br></pre></td></tr></table></figure><p>注：测试操作系统均为64位操作系统，程序也是64位程序，都使用gcc进行编译，使用默认参数进行编译</p><h1 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h1><p>显然在 x64 Windows上，long类型被定义为32位整数，相当于int。而在 x64 Linux 上，<br>则被定义为64位整数，相当于long long。有说法认为在32位Linux上，long是32位的，但暂未实际测试。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C51单片机时钟周期/计时器初值/串口通信波特率</title>
      <link href="/2024/06/C51-Timer-and-baud/"/>
      <url>/2024/06/C51-Timer-and-baud/</url>
      
        <content type="html"><![CDATA[<h1 id="C51时钟周期、机器周期、晶振频率"><a href="#C51时钟周期、机器周期、晶振频率" class="headerlink" title="C51时钟周期、机器周期、晶振频率"></a>C51时钟周期、机器周期、晶振频率</h1><p>C51一般使用内部晶振，即外接晶振元件，内部驱动。晶振频率常取12MHz或11.0592MHz。</p><p>晶振频率的倒数是<strong>时钟周期</strong>，两个时钟周期为一个<strong>拍</strong>，C51规定，六个拍，<br>即12个时钟周期是一个<strong>机器周期</strong>。</p><p>因此，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 / 晶振频率 = 机器周期</span><br></pre></td></tr></table></figure><h1 id="计时器初始值计算"><a href="#计时器初始值计算" class="headerlink" title="计时器初始值计算"></a>计时器初始值计算</h1><p>以方式1为例。方式1是16位计时器，每个机器周期计时器+1，当计数值为 2^16 + 1&#x3D; 65535 + 1 的时候，<br>计时器溢出。因此可以得到，如果要计时器n个机器周期的时间后溢出，则须设置初值为 65536 - n。<br>总的来说，如果已知晶振频率f，计时器计时的时间t，则方式1的计时器初始值 Vinit 为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vinit = 65536 - t / (12 / f)</span><br></pre></td></tr></table></figure><h1 id="串口波特率计算"><a href="#串口波特率计算" class="headerlink" title="串口波特率计算"></a>串口波特率计算</h1><p>波特率通常是人为规定的一系列数值，通常我们使用串口的工作方式1。其公式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baud = (2^(SMOD) / 32) * (T1of)</span><br></pre></td></tr></table></figure><p>SMOD是一个bit型值，是人为设置的。T1of是计时器T1的溢出率（此时T1是工作方式2），其计算公式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T1of = f /&#123;12×[256 - (TH1)]&#125;</span><br></pre></td></tr></table></figure><p>TH1为计时器1高八位初值,f是晶振频率，<strong>单位Hz</strong>。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>如果已知串口规定的波特率为 9600 baud，SMOD &#x3D;&#x3D; 0，则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T1of = baud * 32 = 9600 * 32 = 30720</span><br><span class="line">TH1 = 256 - (f / T1of / 12) = 256 - (11059200 / 30720 / 12) = 253 = 0xfd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 开发 </tag>
            
            <tag> 嵌入式 </tag>
            
            <tag> C51单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>std::memory_order</title>
      <link href="/2024/06/std-memory-order/"/>
      <url>/2024/06/std-memory-order/</url>
      
        <content type="html"><![CDATA[<p>这是一个enum类型，在头文件&lt;atomic&gt;中定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">memory_order</span> &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure><blockquote><p>std::memory_order 指定内存访问，包括常规的非原子内存访问，如何围绕原子操作排序。在没有任何约束的多处理器系统上，多个线程同时读或写数个变量时，一个线程能观测到变量值更改的顺序不同于另一个线程写它们的顺序。实际上，更改的顺序甚至能在多个读取线程间相异。一些类似的效果还能在单处理器系统上出现，因为内存模型允许编译器进行变换。</p></blockquote><blockquote><p>库中所有原子操作的默认行为提供序列一致定序（见后述讨论）。该默认行为可能有损性能，不过可以给予库的原子操作额外的 std::memory_order 实参，以指定确切的约束，在原子性外，编译器和处理器还必须强制该操作。</p></blockquote><p>可以用这个类型的变量来规定“内存访问顺序”。<br>假设现在有n个<strong>atomic</strong>变量，编号为1,2……n，并且有多个线程同时访问这些变量。<br>有些线程读取，有些线程写入，假设写入线程不断按编号顺序依次更新这些变量，<br>则<strong>无法保证</strong>在读取线程中，观测到的变量更改也是按顺序的。（尤其在多处理器系统中）</p><p>因此可以在进行原子操作时传入一个memory_order变量，来规定应这些变量读取顺序。</p><h2 id="个人理解"><a href="#个人理解" class="headerlink" title="个人理解"></a>个人理解</h2><p>memory_order_relaxed 无限制</p><p>memory_order_acquire 确保先进行(标记为relax的操作)再进行这个操作</p><p>memory_order_consume ？</p><p>memory_order_seq_cst ？</p><p>memory_order_seq_cst ？</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 多线程 </tag>
            
            <tag> 内存管理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
